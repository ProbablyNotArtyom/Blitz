===================
Key Request Service
===================

The key request service is part of the key retention service (refer to
Documentation/security/keys/core.rst).  This document explains more fully how
the requesting algorithm works.

The process starts by either the kernel requesting a service by calling
``request_key*()``::

	struct key *request_key(const struct key_type *type,
				const char *description,
				const char *callout_info);

or::

	struct key *request_key_with_auxdata(const struct key_type *type,
					     const char *description,
					     const char *callout_info,
					     size_t callout_len,
					     void *aux);

or::

	struct key *request_key_async(const struct key_type *type,
				      const char *description,
				      const char *callout_info,
				      size_t callout_len);

or::

	struct key *request_key_async_with_auxdata(const struct key_type *type,
						   const char *description,
						   const char *callout_info,
					     	   size_t callout_len,
						   void *aux);

Or by userspace invoking the request_key system call::

	key_serial_t request_key(const char *type,
				 const char *description,
				 const char *callout_info,
				 key_serial_t dest_keyring);

The main difference between the access points is that the in-kernel interface
does not need to link the key to a keyring to prevent it from being immediately
destroyed.  The kernel interface returns a pointer directly to the key, and
it's up to the caller to destroy the key.

The request_key*_with_auxdata() calls are like the in-kernel request_key*()
calls, except that they permit auxiliary data to be passed to the upcaller (the
default is NULL).  This is only useful for those key types that define their
own upcall mechanism rather than using /sbin/request-key.

The two async in-kernel calls may return keys that are still in the process of
being constructed.  The two non-async ones will wait for construction to
complete first.

The userspace interface links the key to a keyring associated with the process
to prevent the key from going away, and returns the serial number of the key to
the caller.


The following example assumes that the key types involved don't define their
own upcall mechanisms.  If they do, then those should be substituted for the
forking and execution of /sbin/request-key.


The Process
===========

A request proceeds in the following manner:

  1) Process A calls request_key() [the userspace syscall calls the kernel
     interface].

  2) request_key() searches the process's subscribed keyrings to see if there's
     a suitable key there.  If there is, it returns the key.  If there isn't,
     and callout_info is not set, an error is returned.  Otherwise the process
     proceeds to the next step.

  3) request_key() sees that A doesn't have the desired key yet, so it creates
     two things:

      a) An uninstantiated key U of requested type and description.

      b) An authorisation key V that refers to key U and notes that process A
     	 is the context in which key U should be instantiated and secured, and
     	 from which associated key requests may be satisfied.

  4) request_key() then forks and executes /sbin/request-key with a new session
     keyring that contains a link to auth key V.

  5) /sbin/request-key assumes the authority associated with key U.

  6) /sbin/request-key execs an appropriate program to perform the actual
     instantiation.

  7) The program may want to access another key from A's context (say a
     Kerberos TGT key).  It just requests the appropriate key, and the keyring
     search notes that the session keyring has auth key V in its bottom level.

     This will permit it to then search the keyrings of process A with the
     UID, GID, groups and security info of process A 