// SPDX-License-Identifier: GPL-2.0
/*
 * arch/alpha/boot/tools/objstrip.c
 *
 * Strip the object file headers/trailers from an executable (ELF or ECOFF).
 *
 * Copyright (C) 1996 David Mosberger-Tang.
 */
/*
 * Converts an ECOFF or ELF object file into a bootable file.  The
 * object file must be a OMAGIC file (i.e., data and bss follow immediately
 * behind the text).  See DEC "Assembly Language Programmer's Guide"
 * documentation for details.  The SRM boot process is documented in
 * the Alpha AXP Architecture Reference Manual, Second Edition by
 * Richard L. Sites and Richard T. Witek.
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>

#include <sys/fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>

#include <linux/a.out.h>
#include <linux/coff.h>
#include <linux/param.h>
#ifdef __ELF__
# include <linux/elf.h>
# define elfhdr elf64_hdr
# define elf_phdr elf64_phdr
# define elf_check_arch(x) ((x)->e_machine == EM_ALPHA)
#endif

/* bootfile size must be multiple of BLOCK_SIZE: */
#define BLOCK_SIZE	512

const char * prog_name;


static void
usage (void)
{
    fprintf(stderr,
	    "usage: %s [-v] -p file primary\n"
	    "       %s [-vb] file [secondary]\n", prog_name, prog_name);
    exit(1);
}


int
main (int argc, char *argv[])
{
    size_t nwritten, tocopy, n, mem_size, fil_size, pad = 0;
    int fd, ofd, i, j, verbose = 0, primary = 0;
    char buf[8192], *inname;
    struct exec * aout;		/* includes file & aout header */
    long offset;
#ifdef __ELF__
    struct elfhdr *elf;
    struct elf_phdr *elf_phdr;	/* program header */
    unsigned long long e_entry;
#endif

    prog_name = argv[0];

    for (i = 1; i < argc && argv[i][0] == '-'; ++i) {
	for (j = 1; argv[i][j]; ++j) {
	    switch (argv[i][j]) {
	      case 'v':
		  verbose = ~verbose;
		  break;

	      case 'b':
		  pad = BLOCK_SIZE;
		  break;

	      case 'p':
		  primary = 1;		/* make primary bootblock */
		  break;
	    }
	}
    }

    if (i >= argc) {
	usage();
    }
    inname = argv[i++];

    fd = open(inname, O_RDONLY);
    if (fd == -1) {
	perror("open");
	exit(1);
    }

    ofd = 1;
    if (i < argc) {
	ofd = open(argv[i++], O_WRONLY | O_CREAT | O_TRUNC, 0666);
	if (ofd == -1) {
	    perror("open");
	    exit(1);
	}
    }

    if (primary) {
	/* generate bootblock for primary loader */
	
	unsigned long bb[64], sum = 0;
	struct stat st;
	off_t size;
	int i;

	if (ofd == 1) {
	    usage();
	}

	if (fstat(fd, &st) == -1) {
	    perror("fstat");
	    exit(1);
	}

	size = (st.st_size + BLOCK_SIZE - 1) & ~(BLOCK_SIZE - 1);
	memset(bb, 0, sizeof(bb));
	strcpy((char *) bb, "Linux SRM bootblock");
	bb[60] = size / BLOCK_SIZE;	/* count */
	bb[61] = 1;			/* starting sector # */
	bb[62] = 0;			/* flags---must be 0 */
	for (i = 0; i < 63; ++i) {
	    sum += bb[i];
	}
	bb[63] = sum;
	if (write(ofd, bb, sizeof(bb)) != sizeof(bb)) {
	    perror("boot-block write");
	    exit(1);
	}
	printf("%lu\n", size);
	return 0;
    }

    /* read and inspect exec header: */

    if (read(fd, buf, sizeof(buf)) < 0) {
	perror("read");
	exit(1);
    }

#ifdef __ELF__
    elf = (struct elfhdr *) buf;

    if (elf->e_ident[0] == 0x7f && strncmp((char *)elf->e_ident + 1, "ELF", 3) == 0) {
	if (elf->e_type != ET_EXEC) {
	    fprintf(stderr, "%s: %s is not an ELF executable\n",
		    prog_name, inname);
	    exit(1);
	}
	if (!elf_check_arch(elf)) {
	    fprintf(stderr, "%s: is not for this processor (e_machine=%d)\n",
		    prog_name, elf->e_machine);
	    exit(1);
	}
	if (elf->e_phnum != 1) {
	    fprintf(stderr,
		    "%s: %d program headers (forgot to link with -N?)\n",
		    prog_name, elf->e_phnum);
	}

	e_entry = elf->e_entry;

	lseek(fd, elf->e_phoff, SEEK_SET);
	if (read(fd, buf, sizeof(*elf_phdr)) != sizeof(*elf_phdr)) {
	    perror("read");
	    exit(1);
	}

	elf_phdr = (struct elf_phdr *) buf;
	offset	 = elf_phdr->p_offset;
	mem_size = elf_phdr->p_memsz;
	fil_size = elf_phdr->p_filesz;

	/* work around ELF bug: */
	if (elf_phdr->p_vaddr < e_entry) {
	    unsigned long delta = e_entry - elf_phdr->p_vaddr;
	    offset   += delta;
	    mem_size -= delta;
	    fil_size -= delta;
	    elf_phdr->p_vaddr += delta;
	}

	if (verbose) {
	    fprintf(stderr, "%s: extracting %#016lx-%#016lx (at %lx)\n",
		    prog_name, (long) elf_phdr->p_vaddr,
		    elf_phdr->p_vaddr + fil_size, offset);
	}
    } else
#endif
    {
	aout = (struct exec *) buf;

	if (!(aout->fh.f_flags & COFF_F_EXEC)) {
	    fprintf(stderr, "%s: %s is not in executable format\n",
		    prog_name, inname);
	    exit(1);
	}

	if (aout->fh.f_opthdr != sizeof(aout->ah)) {
	    fprintf(stderr, "%s: %s has unexpected optional header size\n",
		    prog_name, inname);
	    exit(1);
	}

	if (N_MAGIC(*aout) != OMAGIC) {
	    fprintf(stderr, "%s: %s is not an OMAGIC file\n",
		    prog_name, inname);
	    exit(1);
	}
	offset = N_TXTOFF(*aout);
	fil_size = aout->ah.tsize + aout->ah.dsize;
	mem_size = fil_size + aout->ah.bsize;

	if (verbose) {
	    fprintf(stderr, "%s: extracting %#016lx-%#016lx (at %lx)\n",
		    prog_name, aout->ah.text_start,
		    aout->ah.text_start + fil_size, offset);
	}
    }

    if (lseek(fd, offset, SEEK_SET) != offset) {
	perror("lseek");
	exit(1);
    }

    if (verbose) {
	fprintf(stderr, "%s: copying %lu byte from %s\n",
		prog_name, (unsigned long) fil_size, inname);
    }

    tocopy = fil_size;
    while (tocopy > 0) {
	n = tocopy;
	if (n > sizeof(buf)) {
	    n = sizeof(buf);
	}
	tocopy -= n;
	if ((size_t) read(fd, buf, n) != n) {
	    perror("read");
	    exit(1);
	}
	do {
	    nwritten = write(ofd, buf, n);
	    if ((ssize_t) nwritten == -1) {
		perror("write");
		exit(1);
	    }
	    n -= nwritten;
	} while (n > 0);
    }

    if (pad) {
	mem_size = ((mem_size + pad - 1) / pad) * pad;
    }

    tocopy = mem_size - fil_size;
    if (tocopy > 0) {
	fprintf(stderr,
		"%s: zero-filling bss and aligning to %lu with %lu bytes\n",
		prog_name, pad, (unsigned long) tocopy);

	memset(buf, 0x00, sizeof(buf));
	do {
	    n = tocopy;
	    if (n > sizeof(buf)) {
		n = sizeof(buf);
	    }
	    nwritten = write(ofd, buf, n);
	    if ((ssize_t) nwritten == -1) {
		perror("write");
		exit(1);
	    }
	    tocopy -= nwritten;
	} while (tocopy > 0);
    }
    return 0;
}
agé par cet onglet.Du contenu RV est diffusé sur un casque à partir de cet onglet.$1 –  Enregistrement vidéo ou audio$1 – Contenu de l'onglet partagé$1 – Vidéo diffusée en mode PIP$1 – Lecture audio$1 – Son coupé$1 – Appareil Bluetooth connecté$1 –  Appareil USB connecté$1 (port de série connecté)$1 – Erreur réseau$1 – Plantage$1 – Contenu du bureau partagé$1 – RV diffusée sur un casquePartagerCe site a été mis à jour en arrière-plan.Journal d'appareilsAjoutez un paramètre de requête dans l'URL pour une actualisation automatique de la page : chrome://device-log/?refresh=<sec>Afficher :UtilisateurÉvénementDéboguerAlimentationBluetoothUSBHIDImprimanteFIDOInformations sur le fichierHorodatage détaillé[$1]
        $2
        $3Accédez à la page "$1" pour vous connecter.L'appareil "$1" a été détectéCommunications$1 tente de s'associer"$1" tente de s'associerAucun appareil compatible détecté.$1 pour autoriser l'associationActiver le Bluetooth lors de la recherche d'appareils…Nouvelle rechercheRelancer la recherche d'appareils BluetoothRecherche…Recherche d'appareils Bluetooth…Associer$1 associé$1 tente de se connecter"$1" tente de se connecter$1 ($2)Appareil de $1 inconnuAppareil inconnu [$1:$2]Aucun appareil à proximité n'a été trouvé.$1 souhaite rechercher les appareils Bluetooth à proximité. Les appareils suivants ont été détectés :Appareil inconnu ou non compatible ($1)Produit inconnu $1 fourni par $2Produit inconnu $1 du fournisseur $2Appareils du fournisseur $1Appareils de $1Appareils de n'importe quel fournisseur$1 tente de se connecter à un port de série"$1" tente de se connecter à un port de série$1L'extension $1 peut récupérer tout le texte que vous saisissez, y compris des données personnelles telles que des mots de passe et des numéros de carte de paiement. Souhaitez-vous utiliser cette extension ?Ne plus afficherToujours autoriser les annonces sur ce siteAnnonces bloquéesCe site affiche des annonces intrusives ou trompeuses.Annonces bloquées sur ce siteUtilitaires WindowsRedirection bloquée :Redirection bloquéeRedirection bloquée sur cette page.Le navigateur Web de Google, pour vousConnectez-vous à Chrome avec votre compte Google pour synchroniser vos favoris, votre historique, vos mots de passe et d'autres paramètres sur tous vos appareils.Naviguez à toute vitesse avec Google ChromeNaviguez en toute sécurité avec Google ChromeNaviguez intelligemment avec ChromePassez à un navigateur rapidePassez à un navigateur intelligentPassez à un navigateur sécuriséPassez à un navigateur intelligent et sécuriséGoogle recommande ChromeOuvrir ChromeOuvrir les paramètres WindowsCliquez sur <strong>Microsoft Edge</strong> sous "Navigateur Web".Changer quand mêmeFaites un clic droit sur l'icône <div class="logo-small"></div> dans la barre des tâches.Sélectionnez <strong>Épingler à la barre des tâches</strong>.Épingler à la barre des tâchesChrome est contrôlé par un logiciel de test automatisé.Voir la marque et le modèle de votre clé de sécuritéOuvrir le fichier téléchargéAutoriser $1 à ouvrir le fichier $2 ?{0,plural, =1{Importer un fichier sur ce site ?}one{Importer # fichier sur ce site ?}other{Importer # fichiers sur ce site ?}}Tous les fichiers seront téléchargés depuis "$1". N'effectuez cette opération que s'il s'agit d'un site de confiance.Relancer maintenantUtiliser votre clé de sécurité avec $1$1 souhaite valider votre identitéLa validation de votre identité contribue à protéger vos informations personnellesValider votre identité avec $1Sélectionnez une optionClé de sécurité BluetoothClé de sécurité USBClé de sécurité NFCCapteur intégréVotre téléphoneClé de sécurité externe ou capteur intégréInsérez votre clé de sécurité et appuyez dessusUn problème est survenuEssayer une autre clé de sécuritéCette clé de sécurité est déjà enregistrée. Il n'est pas nécessaire de l'enregistrer à nouveau.La clé de sécurité n'est pas enregistrée auprès de ce site WebLe délai imparti à la demande est dépasséImpossible de valider votre identitéCet appareil n'est pas compatible avec la clé de sécurité demandée par le site WebActiver le Bluetooth ?Chrome va activer provisoirement le Bluetooth pour pouvoir communiquer avec votre clé de sécuritéBluetooth désactivéActivez le Bluetooth dans les paramètres de votre appareil pour continuerPrêt à associer votre clé de sécurité ?Associez votre clé de sécurité à cet appareil afin de pouvoir l'utiliser pour vous connecter à votre compteCommencerAppuyez sur le bouton situé sur votre clé de sécurité pendant au moins cinq secondesSélectionner votre clé de sécuritéLocalisez le nom imprimé au dos de votre clé de sécuritéRecherche en cours…Si votre clé de sécurité ne figure pas dans la liste, appuyez sur le bouton de la clé pendant au moins cinq secondes.Associer à $1Localisez le code à six chiffres au dos de votre clé de sécuritéValidation de votre clé de sécurité…Appuyez sur le bouton de la clé de sécuritéSélectionner une autre optionValider via USBValider via BluetoothAjouter une clé de sécurité BluetoothValider via NFCValider via le capteur intégréValider via le téléphoneVérifier le téléphoneUne notification a été envoyée à votre téléphone pour que vous puissiez confirmer votre identité.Veuillez saisir un codeSaisissez le code associé à votre clé de sécuritéConfigurez un nouveau code pour votre clé de sécuritéCe code contient des caractères non validesLe code doit comporter au moins 4 caractères.{NUM_ATTEMPTS,plural, =1{Code incorrect. Il vous reste une tentative.}one{Code incorrect. Il vous reste # tentative.}other{Code incorrect. Il vous reste # tentatives.}}Appuyez de nouveau sur votre clé de sécurité pour finaliser la requête.Les codes saisis ne correspondent pasRéinsérez votre clé de sécurité et réessayezSélectionnez le compte avec lequel vous connecterCompte inconnuUne trace de votre visite sur le site sera conservée sur votre clé de sécurité.Impossible d'utiliser votre clé de sécurité sur ce site$1 peut exiger un type de clé de sécurité plus récent ou différentL'espace de stockage de votre clé de sécurité est insuffisant pour y enregistrer d'autres comptes.Autoriser ce site à lire les informations de votre clé de sécurité ?$1 souhaite voir la marque et le modèle de votre clé de sécuritéNavigation privée{0,plural, =1{# fenêtre ouverte}one{# fenêtre ouverte}other{# fenêtres ouvertes}}Quitter le mode navigation privée7025https://chrome.google.com/webstore?hl=fr&category=theme782681https://myactivity.google.com/myactivity/?utm_source=chrome_nhttps://myactivity.google.com/myactivity/?utm_source=chrome_hAccédez au
        menu Chrome >
        <span jscontent="settingsTitle"></span>
        >
        <span jscontent="advancedTitle"></span>,
        puis décochez l'option "<span jscontent="noNetworkPredictionTitle"></span>".
        Si le problème persiste, nous vous conseillons de réactiver
        cette option pour des performances optimales.Autorisez Chrome à accéder au réseau dans les paramètres du pare-feu ou
        de l'antivirus.La configuration initiale de Chrome OS n'est pas terminée.Accédez au
          menu Chrome >
          <span jscontent="settingsTitle"></span>
          >
          <span jscontent="advancedTitle"></span>
          >
          <span jscontent="proxyTitle"></span>
          >
          Paramètres réseau,
          puis décochez l'option "Utiliser un serveur proxy pour votre réseau local".Vos modifications seront prises en compte au prochain redémarrage de Google Chrome.Cette page affiche uniquement des informations sur les erreurs récentes si vous <a href="https://support.google.com/chrome/answer/96817">activez l'envoi de rapports d'erreur</a>.Google Chrome fonctionne grâce au projet Open Source <a target="_blank" href="$1">Chromium</a