                          The Linux RapidIO Subsystem

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The RapidIO standard is a packet-based fabric interconnect standard designed for
use in embedded systems. Development of the RapidIO standard is directed by the
RapidIO Trade Association (RTA). The current version of the RapidIO specification
is publicly available for download from the RTA web-site [1].

This document describes the basics of the Linux RapidIO subsystem and provides
information on its major components.

1 Overview
----------

Because the RapidIO subsystem follows the Linux device model it is integrated
into the kernel similarly to other buses by defining RapidIO-specific device and
bus types and registering them within the device model.

The Linux RapidIO subsystem is architecture independent and therefore defines
architecture-specific interfaces that provide support for common RapidIO
subsystem operations.

2. Core Components
------------------

A typical RapidIO network is a combination of endpoints and switches.
Each of these components is represented in the subsystem by an associated data
structure. The core logical components of the RapidIO subsystem are defined
in include/linux/rio.h file.

2.1 Master Port

A master port (or mport) is a RapidIO interface controller that is local to the
processor executing the Linux code. A master port generates and receives RapidIO
packets (transactions). In the RapidIO subsystem each master port is represented
by a rio_mport data structure. This structure contains master port specific
resources such as mailboxes and doorbells. The rio_mport also includes a unique
host device ID that is valid when a master port is configured as an enumerating
host.

RapidIO master ports are serviced by subsystem specific mport device drivers
that provide functionality defined for this subsystem. To provide a hardware
independent interface for RapidIO subsystem operations, rio_mport structure
includes rio_ops data structure which contains pointers to hardware specific
implementations of RapidIO functions.

2.2 Device

A RapidIO device is any endpoint (other than mport) or switch in the network.
All devices are presented in the RapidIO subsystem by corresponding rio_dev data
structure. Devices form one global device list and per-network device lists
(depending on number of available mports and networks).

2.3 Switch

A RapidIO switch is a special class of device that routes packets between its
ports towards their final destination. The packet destination port within a
switch is defined by an internal routing table. A switch is presented in the
RapidIO subsystem by rio_dev data structure expanded by additional rio_switch
data structure, which contains switch specific information such as copy of the
routing table and pointers to switch specific functions.

The RapidIO subsystem defines the format and initialization method for subsystem
specific switch drivers that are designed to provide hardware-specific
implementation of common switch management routines.

2.4 Network

A RapidIO network is a combination of interconnected endpoint and switch devices.
Each RapidIO network known to the system is represented by corresponding rio_net
data structure. This structure includes lists of all devices and local master
ports that form the same network. It also contains a pointer to the default
master port that is used to communicate with devices within the network.

2.5 Device Drivers

RapidIO device-specific drivers follow Linux Kernel Driver Model and are
intended to support specific RapidIO devices attached to the RapidIO network.

2.6 Subsystem Interfaces

RapidIO interconnect specification defines features that may be used to provide
one or more common service layers for all participating RapidIO devices. These
common services may act separately from device-specific drivers or be used by
device-specific drivers. Example of such service provider is the RIONET driver
which implements Ethernet-over-RapidIO interface. Because only one driver can be
registered for a device, all common RapidIO services have to be registered as
subsystem interfaces. This allows to have multiple common services attached to
the same device without blocking attachment of a device-specific driver.

3. Subsystem Initialization
---------------------------

In order to initialize the RapidIO subsystem, a platform must initialize and
register at least one master port within the RapidIO network. To register mport
within the subsystem controller driver's initialization code calls function
rio_register_mport() for each available master port.

After all active master ports are registered with a RapidIO subsystem,
an enumeration and/or discovery routine may be called automatically or
by user-space command.

RapidIO subsystem can be configured to be built as a statically linked or
modular component of the kernel (see details below).

4. Enumeration and Discovery
----------------------------

4.1 Overview
------------

RapidIO subsystem configuration options allow users to build enumeration and
discovery methods as statically linked components or loadable modules.
An enumeration/discovery method implementation and available input parameters
define how any given method can be attached to available RapidIO mports:
simply to all available mports OR individually to the specified mport device.

Depending on selected enumeration/discovery build configuration, there are
several methods to initiate an enumeration and/or discovery process:

  (a) Statically linked enumeration and discovery process can be started
  automatically during kernel initialization time using corresponding module
  parameters. This was the original method used since introduction of RapidIO
  subsystem. Now this method relies on enumerator module parameter which is
  'rio-scan.scan' for existing basic enumeration/discovery method.
  When automatic start of enumeration/discovery is used a user has to ensure
  that all discovering endpoints are started before the enumerating endpoint
  and are waiting for enumeration to be completed.
  Configuration option CONFIG_RAPIDIO_DISC_TIMEOUT defines time that discovering
  endpoint waits for enumeration to be completed. If the specified timeout
  expires the discovery process is terminated without obtaining RapidIO network
  information. NOTE: a timed out discovery process may be restarted later using
  a user-space command as it is described below (if the given endpoint was
  enumerated successfully).

  (b) Statically linked enumeration and discovery process can be started by
  a command from user space. This initiation method provides more flexibility
  for a system startup compared to the option (a) above. After all participating
  endpoints have been successfully booted, an enumeration process shall be
  started first by issuing a user-space command, after an enumeration is
  completed a discovery process can be started on all remaining endpoints.

  (c) Modular enumeration and discovery process can be started by a command from
  user space. After an enumeration/discovery module is loaded, a network scan
  process can be started by issuing a user-space command.
  Similar to the option (b) above, an enumerator has to be started first.

  (d) Modular enumeration and discovery process can be started by a module
  initialization routin