This is gmp.info, produced by makeinfo version 4.0 from gmp.texi.

START-INFO-DIR-ENTRY
* gmp: (gmp.info).               GNU Multiple Precision Arithmetic Library.
END-INFO-DIR-ENTRY

   This file documents GNU MP, a library for arbitrary-precision
arithmetic.

   Copyright (C) 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.


File: gmp.info,  Node: I/O of Integers,  Next: Miscellaneous Integer Functions,  Prev: Integer Logic and Bit Fiddling,  Up: Integer Functions

Input and Output Functions
==========================

   Functions that perform input from a stdio stream, and functions that
output to a stdio stream.  Passing a NULL pointer for a STREAM argument
to any of these functions will make them read from `stdin' and write to
`stdout', respectively.

   When using any of these functions, it is a good idea to include
`stdio.h' before `gmp.h', since that will allow `gmp.h' to define
prototypes for these functions.

 - Function: size_t mpz_out_str (FILE *STREAM, int BASE, mpz_t OP)
     Output OP on stdio stream STREAM, as a string of digits in base
     BASE.  The base may vary from 2 to 36.

     Return the number of bytes written, or if an error occurred,
     return 0.

 - Function: size_t mpz_inp_str (mpz_t ROP, FILE *STREAM, int BASE)
     Input a possibly white-space preceded string in base BASE from
     stdio stream STREAM, and put the read integer in ROP.  The base
     may vary from 2 to 36.  If BASE is 0, the actual base is
     determined from the leading characters: if the first two
     characters are `0x' or `0X', hexadecimal is assumed, otherwise if
     the first character is `0', octal is assumed, otherwise decimal is
     assumed.

     Return the number of bytes read, or if an error occurred, return 0.

 - Function: size_t mpz_out_raw (FILE *STREAM, mpz_t OP)
     Output OP on stdio stream STREAM, in raw binary format.  The
     integer is written in a portable format, with 4 bytes of size
     information, and that many bytes of limbs.  Both the size and the
     limbs are written in decreasing significance order (i.e., in
     big-endian).

     The output can be read with `mpz_inp_raw'.

     Return the number of bytes written, or if an error occurred,
     return 0.

     The output of this can not be read by `mpz_inp_raw' from GMP 1,
     because of changes necessary for compatibility between 32-bit and
     64-bit machines.

 - Function: size_t mpz_inp_raw (mpz_t ROP, FILE *STREAM)
     Input from stdio stream STREAM in the format written by
     `mpz_out_raw', and put the result in ROP.  Return the number of
     bytes read, or if an error occurred, return 0.

     This routine can read the output from `mpz_out_raw' also from GMP
     1, in spite of changes necessary for compatibility between 32-bit
     and 64-bit machines.


File: gmp.info,  Node: Miscellaneous Integer Functions,  Prev: I/O of Integers,  Up: Integer Functions

Miscellaneous Functions
=======================

 - Function: int mpz_fits_ulong_p (mpz_t OP)
 - Function: int mpz_fits_slong_p (mpz_t OP)
 - Function: int mpz_fits_uint_p (mpz_t OP)
 - Function: int mpz_fits_sint_p (mpz_t OP)
 - Function: int mpz_fits_ushort_p (mpz_t OP)
 - Function: int mpz_fits_sshort_p (mpz_t OP)
     Return non-zero iff the value of OP fits in an `unsigned long int',
     `signed long int', `unsigned int', `signed int', `unsigned short
     int', or `signed short int', respectively.  Otherwise, return zero.

   The random number functions of GMP come in two groups; older function
that rely on a global state, and newer functions that accept a state
parameter that is read and modified.  Please see the *Note Random
Number Functions:: for more information on how to use and not to use
random number functions.

 - Function: void mpz_urandomb (mpz_t ROP, gmp_randstate_t STATE,
     unsigned long int N) Generate a uniform random integer in the range
     0 to 2^N - 1, inclusive.

     The variable STATE must be initialized by calling one of the
     `gmp_randinit' functions (*Note Random State Initialization::)
     before invoking this function.

 - Function: void mpz_urandomm (mpz_t ROP, gmp_randstate_t STATE,
     mpz_t N) Generate a uniform random integer in the range 0 to N -
     1, inclusive.

     The variable STATE must be initialized by calling one of the
     `gmp_randinit' functions (*Note Random State Initialization::)
     before invoking this function.

 - Function: void mpz_rrandomb (mpz_t ROP, gmp_randstate_t STATE,
          unsigned long int N)
     Generate a random integer with long strings of zeros and ones in
     the binary representation.  Useful for testing functions and
     algorithms, since this kind of random numbers have proven to be
     more likely to trigger corner-case bugs.  The random number will
     be in the range 0 to 2^N - 1, inclusive.

     The variable STATE must be initialized by calling one of the
     `gmp_randinit' functions (*Note Random State Initialization::)
     before invoking this function.

 - Function: size_t mpz_size (mpz_t OP)
     Return the size of OP measured in number of limbs.  If OP is zero,
     the returned value will be zero.

 - Function: size_t mpz_sizeinbase (mpz_t OP, int BASE)
     Return the size of OP measured in number of digits in base BASE.
     The base may vary from 2 to 36.  The returned value will be exact
     or 1 too big.  If BASE is a power of 2, the returned value will
     always be exact.

     This function is useful in order to allocate the right amount of
     space before converting OP to a string.  The right amount of
     allocation is normally two more than the value returned by
     `mpz_sizeinbase' (one extra for a minus sign and one for the
     terminating '\0').

 - Function: void mpz_random (mpz_t ROP, mp_size_t MAX_SIZE)
     Generate a random integer of at most MAX_SIZE limbs.  The generated
     random number doesn't satisfy any particular requirements of
     randomness.  Negative random numbers are generated when MAX_SIZE
     is negative.

     This function is obsolete.  Use `mpz_urandomb' or `mpz_urandomm'
     instead.

 - Function: void mpz_random2 (mpz_t ROP, mp_size_t MAX_SIZE)
     Generate a random integer of at most MAX_SIZE limbs, with long
     strings of zeros and ones in the binary representation.  Useful
     for testing functions and algorithms, since this kind of random
     numbers have proven to be more likely to trigger corner-case bugs.
     Negative random numbers are generated when MAX_SIZE is negative.

     This function is obsolete.  Use `mpz_rrandomb' instead.


File: gmp.info,  Node: Rational Number Functions,  Next: Floating-point Functions,  Prev: Integer Functions,  Up: Top

Rational Number Functions
*************************

   This chapter describes the GMP functions for performing arithmetic
on rational numbers.  These functions start with the prefix `mpq_'.

   Rational numbers are stored in objects of type `mpq_t'.

   All rational arithmetic functions assume operands have a canonical
form, and canonicalize their result.  The canonical from means that the
denominator and the numerator have no common factors, and that the
denominator is positive.  Zero has the unique representation 0/1.

   Pure assignment functions do not canonicalize the assigned variable.
It is the responsibility of the user to canonicalize the assigned
variable before any arithmetic operations are performed on that
variable.  *Note that this is an incompatible change from version 1 of
the library.*

 - Function: void mpq_canonicalize (mpq_t OP)
     Remove any factors that are common to the numerator and
     denominator of OP, and make the denominator positive.

* Menu:

* Initializing Rationals::
* Assigning Rationals::
* Simultaneous Integer Init & Assign::
* Comparing Rationals::
* Applying Integer Functions::
* Miscellaneous Rational Functions::


File: gmp.info,  Node: Initializing Rationals,  Next: Assigning Rationals,  Prev: Rational Number Functions,  Up: Rational Number Functions

Initialization and Assignment Functions
=======================================

 - Function: void mpq_init (mpq_t DEST_RATIONAL)
     Initialize DEST_RATIONAL and set it to 0/1.  Each variable should
     normally only be initialized once, or at least cleared out (using
     the function `mpq_clear') between each initialization.

 - Function: void mpq_clear (mpq_t RATIONAL_NUMBER)
     Free the space occupied by RATIONAL_NUMBER.  Make sure to call this
     function for all `mpq_t' variables when you are done with them.

 - Function: void mpq_set (mpq_t ROP, mpq_t OP)
 - Function: void mpq_set_z (mpq_t ROP, mpz_t OP)
     Assign ROP from OP.

 - Function: void mpq_set_ui (mpq_t ROP, unsigned long int OP1,
          unsigned long int OP2)
 - Function: void mpq_set_si (mpq_t ROP, signed long int OP1, unsigned
          long int OP2)
     Set the value of ROP to OP1/OP2.  Note that if OP1 and OP2 have
     common factors, ROP has to be passed to `mpq_canonicalize' before
     any operations are performed on ROP.


File: gmp.info,  Node: Assigning Rationals,  Next: Comparing Rationals,  Prev: Initializing Rationals,  Up: Rational Number Functions

Arithmetic Functions
====================

 - Function: void mpq_add (mpq_t SUM, mpq_t ADDEND1, mpq_t ADDEND2)
     Set SUM to ADDEND1 + ADDEND2.

 - Function: void mpq_sub (mpq_t DIFFERENCE, mpq_t MINUEND, mpq_t
          SUBTRAHEND)
     Set DIFFERENCE to MINUEND - SUBTRAHEND.

 - Function: void mpq_mul (mpq_t PRODUCT, mpq_t MULTIPLIER, mpq_t
          MULTIPLICAND)
     Set PRODUCT to MULTIPLIER times MULTIPLICAND.

 - Function: void mpq_div (mpq_t QUOTIENT, mpq_t DIVIDEND, mpq_t
          DIVISOR)
     Set QUOTIENT to DIVIDEND/DIVISOR.

 - Function: void mpq_neg (mpq_t NEGATED_OPERAND, mpq_t OPERAND)
     Set NEGATED_OPERAND to -OPERAND.

 - Function: void mpq_inv (mpq_t INVERTED_NUMBER, mpq_t NUMBER)
     Set INVERTED_NUMBER to 1/NUMBER.  If the new denominator is zero,
     this routine will divide by zero.


File: gmp.info,  Node: Comparing Rationals,  Next: Applying Integer Functions,  Prev: Assigning Rationals,  Up: Rational Number Functions

Comparison Functions
====================

 - Function: int mpq_cmp (mpq_t OP1, mpq_t OP2)
     Compare OP1 and OP2.  Return a positive value if OP1 > OP2, zero
     if OP1 = OP2, and a negative value if OP1 < OP2.

     To determine if two rationals are equal, `mpq_equal' is faster than
     `mpq_cmp'.

 - Macro: int mpq_cmp_ui (mpq_t OP1, unsigned long int NUM2, unsigned
          long int DEN2)
     Compare OP1 and NUM2/DEN2.  Return a positive value if OP1 >
     NUM2/DEN2, zero if OP1 = NUM2/DEN2, and a negative value if OP1 <
     NUM2/DEN2.

     This routine allows that NUM2 and DEN2 have common factors.

     This function is actually implemented as a macro.  It evaluates its
     arguments multiple times.

 - Macro: int mpq_sgn (mpq_t OP)
     Return +1 if OP > 0, 0 if OP = 0, and -1 if OP < 0.

     This function is actually implemented as a macro.  It evaluates its
     arguments multiple times.

 - Function: int mpq_equal (mpq_t OP1, mpq_t OP2)
     Return non-zero if OP1 and OP2 are equal, zero if they are
     non-equal.  Although `mpq_cmp' can be used for the same purpose,
     this function is much faster.


File: gmp.info,  Node: Applying Integer Functions,  Next: Miscellaneous Rational Functions,  Prev: Comparing Rationals,  Up: Rational Number Functions

Applying Integer Functions to Rationals
=======================================

   The set of `mpq' functions is quite small.  In particular, there are
no functions for either input or output.  But there are two macros that
allow us to apply any `mpz' function on the numerator or denominator of
a rational number.  If these macros are used to assign to the rational
number, `mpq_canonicalize' normally need to be called afterwards.

 - Macro: mpz_t mpq_numref (mpq_t OP)
 - Macro: mpz_t mpq_denref (mpq_t OP)
     Return a reference to the numerator and denominator of OP,
     respectively.  The `mpz' functions can be used on the result of
     these macros.


File: gmp.info,  Node: Miscellaneous Rational Functions,  Prev: Applying Integer Functions,  Up: Rational Number Functions

Miscellaneous Functions
=======================

 - Function: double mpq_get_d (mpq_t OP)
     Convert OP to a double.

 - Function: double mpq_set_d (mpq_t ROP, double D)
     Set ROP to the value of d, without rounding.

   These functions assign between either the numerator or denominator
of a rational, and an integer.  Instead of using these functions, it is
preferable to use the more general mechanisms `mpq_numref' and
`mpq_denref', together with `mpz_set'.

 - Function: void mpq_set_num (mpq_t RATIONAL, mpz_t NUMERATOR)
     Copy NUMERATOR to the numerator of RATIONAL.  When this risks to
     make the numerator and denominator of RATIONAL have common
     factors, you have to pass RATIONAL to `mpq_canonicalize' before
     any operations are performed on RATIONAL.

     This function is equivalent to `mpz_set (mpq_numref (RATIONAL),
     NUMERATOR)'.

 - Function: void mpq_set_den (mpq_t RATIONAL, mpz_t DENOMINATOR)
     Copy DENOMINATOR to the denominator of RATIONAL.  When this risks
     to make the numerator and denominator of RATIONAL have common
     factors, or if the denominator might be negative, you have to pass
     RATIONAL to `mpq_canonicalize' before any operations are performed
     on RATIONAL.

     *In version 1 of the library, negative denominators were handled by
     copying the sign to the numerator.  That is no longer done.*

     This function is equivalent to `mpz_set (mpq_denref (RATIONAL),
     DENOMINATORS)'.

 - Function: void mpq_get_num (mpz_t NUMERATOR, mpq_t RATIONAL)
     Copy the numerator of RATIONAL to the integer NUMERATOR, to
     prepare for integer operations on the numerator.

     This function is equivalent to `mpz_set (NUMERATOR, mpq_numref
     (RATIONAL))'.

 - Function: void mpq_get_den (mpz_t DENOMINATOR, mpq_t RATIONAL)
     Copy the denominator of RATIONAL to the integer DENOMINATOR, to
     prepare for integer operations on the denominator.

     This function is equivalent to `mpz_set (DENOMINATOR, mpq_denref
     (RATIONAL))'.


File: gmp.info,  Node: Floating-point Functions,  Next: Low-level Functions,  Prev: Rational Number Functions,  Up: Top

Floating-point Functions
************************

   This chapter describes the GMP functions for performing floating
point arithmetic.  These functions start with the prefix `mpf_'.

   GMP integers are stored in objects of type `mpf_t'.

   The GMP floating-point functions have an interface that is similar
to the GMP integer functions.  The function prefix for floating-point
operations is `mpf_'.

   There is one significant characteristic of floating-point numbers
that has motivated a difference between this function class and other
GMP function classes: the inherent inexactness of floating point
arithmetic.  The user has to specify the precision of each variable.  A
computation that assigns a variable will take place with the precision
of the assigned variable; the precision of variables used as input is
ignored.

   The precision of a calculation is defined as follows: Compute the
requested operation exactly (with "infinite precision"), and truncate
the result to the destination variable precision.  Even if the user has
asked for a very high precision, GMP will not calculate with
superfluous digits.  For example, if two low-precision numbers of
nearly equal magnitude are added, the precision of the result will be
limited to what is required to represent the result accurately.

   The GMP floating-point functions are _not_ intended as a smooth
extension to the IEEE P754 arithmetic.  Specifically, the results
obtained on one computer often differs from the results obtained on a
computer with a different word size.

* Menu:

* Initializing Floats::
* Assigning Floats::
* Simultaneous Float Init & Assign::
* Converting Floats::
* Float Arithmetic::
* Float Comparison::
* I/O of Floats::
* Miscellaneous Float Functions::


File: gmp.info,  Node: Initializing Floats,  Next: Assigning Floats,  Up: Floating-point Functions

Initialization and Assignment Functions
=======================================

 - Function: void mpf_set_default_prec (unsigned long int PREC)
     Set the default precision to be *at least* PREC bits.  All
     subsequent calls to `mpf_init' will use this precision, but
     previously initialized variables are unaffected.

   An `mpf_t' object must be initialized before storing the first value
in it.  The functions `mpf_init' and `mpf_init2' are used for that
purpose.

 - Function: void mpf_init (mpf_t X)
     Initialize X to 0.  Normally, a variable should be initialized
     once only or at least be cleared, using `mpf_clear', between
     initializations.  The precision of X is undefined unless a default
     precision has already been established by a call to
     `mpf_set_default_prec'.

 - Function: void mpf_init2 (mpf_t X, unsigned long int PREC)
     Initialize X to 0 and set its precision to be *at least* PREC
     bits.  Normally, a variable should be initialized once only or at
     least be cleared, using `mpf_clear', between initializations.

 - Function: void mpf_clear (mpf_t X)
     Free the space occupied by X.  Make sure to call this function for
     all `mpf_t' variables when you are done with them.

   Here is an example on how to initialize floating-point variables:
     {
       mpf_t x, y;
       mpf_init (x);			/* use default precision */
       mpf_init2 (y, 256);		/* precision _at least_ 256 bits */
       ...
       /* Unless the program is about to exit, do ... */
       mpf_clear (x);
       mpf_clear (y);
     }

   The following three functions are useful for changing the precision
during a calculation.  A typical use would be for adjusting the
precision gradually in iterative algorithms like Newton-Raphson, making
the computation precision closely match the actual accurate part of the
numbers.

 - Function: void mpf_set_prec (mpf_t ROP, unsigned long int PREC)
     Set the precision of ROP to be *at least* PREC bits.  Since
     changing the precision involves calls to `realloc', this routine
     should not be called in a tight loop.

 - Function: unsigned long int mpf_get_prec (mpf_t OP)
     Return the precision actually used for assignments of OP.

 - Function: void mpf_set_prec_raw (mpf_t ROP, unsigned long int PREC)
     Set the precision of ROP to be *at least* PREC bits.  This is a
     low-level function that does not change the allocation.  The PREC
     argument must not be larger that the precision previously returned
     by `mpf_get_prec'.  It is crucial that the precision of ROP is
     ultimately reset to exactly the value returned by `mpf_get_prec'
     before the first call to `mpf_set_prec_raw'.


File: gmp.info,  Node: Assigning Floats,  Next: Simultaneous Float Init & Assign,  Prev: Initializing Floats,  Up: Floating-point Functions

Assignment Functions
--------------------

   These functions assign new values to already initialized floats
(*note Initializing Floats::).

 - Function: void mpf_set (mpf_t ROP, mpf_t OP)
 - Function: void mpf_set_ui (mpf_t ROP, unsigned long int OP)
 - Function: void mpf_set_si (mpf_t ROP, signed long int OP)
 - Function: void mpf_set_d (mpf_t ROP, double OP)
 - Function: void mpf_set_z (mpf_t ROP, mpz_t OP)
 - Function: void mpf_set_q (mpf_t ROP, mpq_t OP)
     Set the value of ROP from OP.

 - Function: int mpf_set_str (mpf_t ROP, char *STR, int BASE)
     Set the value of ROP from the string in STR.  The string is of the
     form `M@N' or, if the base is 10 or less, alternatively `MeN'.
     `M' is the mantissa and `N' is the exponent.  The mantissa is
     always in the specified base.  The exponent is either in the
     specified base or, if BASE is negative, in decimal.

     The argument BASE may be in the ranges 2 to 36, or -36 to -2.
     Negative values are used to specify that the exponent is in
     decimal.

     Unlike the corresponding `mpz' function, the base will not be
     determined from the leading characters of the string if BASE is 0.
     This is so that numbers like `0.23' are not interpreted as octal.

     White space is allowed in the string, and is simply ignored.

     This function returns 0 if the entire string up to the '\0' is a
     valid number in base BASE.  Otherwise it returns -1.


File: gmp.info,  Node: Simultaneous Float Init & Assign,  Next: Converting Floats,  Prev: Assigning Floats,  Up: Floating-point Functions

Combined Initialization and Assignment Functions
------------------------------------------------

   For convenience, GMP provides a parallel series of
initialize-and-set functions which initialize the output and then store
the value there.  These functions' names have the form `mpf_init_set...'

   Once the float has been initialized by any of the `mpf_init_set...'
functions, it can be used as the source or destination operand for the
ordinary float functions.  Don't use an initialize-and-set function on
a variable already initialized!

 - Function: void mpf_init_set (mpf_t ROP, mpf_t OP)
 - Function: void mpf_init_set_ui (mpf_t ROP, unsigned long int OP)
 - Function: void mpf_init_set_si (mpf_t ROP, signed long int OP)
 - Function: void mpf_init_set_d (mpf_t ROP, double OP)
     Initialize ROP and set its value from OP.

     The precision of ROP will be taken from the active default
     precision, as set by `mpf_set_default_prec'.

 - Function: int mpf_init_set_str (mpf_t ROP, char *STR, int BASE)
     Initialize ROP and set its value from the string in STR.  See
     `mpf_set_str' above for details on the assignment operation.

     Note that ROP is initialized even if an error occurs.  (I.e., you
     have to call `mpf_clear' for it.)

     The precision of ROP will be taken from the active default
     precision, as set by `mpf_set_default_prec'.


File: gmp.info,  Node: Converting Floats,  Next: Float Arithmetic,  Prev: Simultaneous Float Init & Assign,  Up: Floating-point Functions

Conversion Functions
====================

 - Function: double mpf_get_d (mpf_t OP)
     Convert OP to a double.

 - Function: char * mpf_get_str (char *STR, mp_exp_t *EXPPTR, int BASE,
          size_t N_DIGITS, mpf_t OP)
     Convert OP to a string of digits in base BASE.  The base may vary
     from 2 to 36.  Generate at most N_DIGITS significant digits, or if
     N_DIGITS is 0, the maximum number of digits accurately
     representable by OP.

     If STR is NULL, space for the mantissa is allocated using the
     default allocation function.

     If STR is not NULL, it should point to a block of storage enough
     large for the mantissa, i.e., N_DIGITS + 2.  The two extra bytes
     are for a possible minus sign, and for the terminating null
     character.

     The exponent is written through the pointer EXPPTR.

     If N_DIGITS is 0, the maximum number of digits meaningfully
     achievable from the precision of OP will be generated.  Note that
     the space requirements for STR in this case will be impossible for
     the user to predetermine.  Therefore, you need to pass NULL for
     the string argument whenever N_DIGITS is 0.

     The generated string is a fraction, with an implicit radix point
     immediately to the left of the first digit.  For example, the
     number 3.1416 would be returned as "31416" in the string and 1
     written at EXPPTR.

     A pointer to the result string is returned.  This pointer will
     will either equal STR, or if that is NULL, will point to the
     allocated storage.


File: gmp.info,  Node: Float Arithmetic,  Next: Float Comparison,  Prev: Converting Floats,  Up: Floating-point Functions

Arithmetic Functions
====================

 - Function: void mpf_add (mpf_t ROP, mpf_t OP1, mpf_t OP2)
 - Function: void mpf_add_ui (mpf_t ROP, mpf_t OP1, unsigned long int
          OP2)
     Set ROP to OP1 + OP2.

 - Function: void mpf_sub (mpf_t ROP, mpf_t OP1, mpf_t OP2)
 - Function: void mpf_ui_sub (mpf_t ROP, unsigned long int OP1, mpf_t
          OP2)
 - Function: void mpf_sub_ui (mpf_t ROP, mpf_t OP1, unsigned long int
          OP2)
     Set ROP to OP1 - OP2.

 - Function: void mpf_mul (mpf_t ROP, mpf_t OP1, mpf_t OP2)
 - Function: void mpf_mul_ui (mpf_t ROP, mpf_t OP1, unsigned long int
          OP2)
     Set ROP to OP1 times OP2.

   Division is undefined if the divisor is zero, and passing a zero
divisor to the divide functions will make these functions intentionally
divide by zero.  This lets the user handle arithmetic exceptions in
these functions in the same manner as other arithmetic exceptions.

 - Function: void mpf_div (mpf_t ROP, mpf_t OP1, mpf_t OP2)
 - Function: void mpf_ui_div (mpf_t ROP, unsigned long int OP1, mpf_t
          OP2)
 - Function: void mpf_div_ui (mpf_t ROP, mpf_t OP1, unsigned long int
          OP2)
     Set ROP to OP1/OP2.

 - Function: void mpf_sqrt (mpf_t ROP, mpf_t OP)
 - Function: void mpf_sqrt_ui (mpf_t ROP, unsigned long int OP)
     Set ROP to the square root of OP.

 - Function: void mpf_pow_ui (mpf_t ROP, mpf_t OP1, unsigned long int
          OP2)
     Set ROP to OP1 raised to the power OP2.

 - Function: void mpf_neg (mpf_t ROP, mpf_t OP)
     Set ROP to -OP.

 - Function: void mpf_abs (mpf_t ROP, mpf_t OP)
     Set ROP to the absolute value of OP.

 - Function: void mpf_mul_2exp (mpf_t ROP, mpf_t OP1, unsigned long int
          OP2)
     Set ROP to OP1 times 2 raised to OP2.

 - Function: void mpf_div_2exp (mpf_t ROP, mpf_t OP1, unsigned long int
          OP2)
     Set ROP to OP1 divided by 2 raised to OP2.


File: gmp.info,  Node: Float Comparison,  Next: I/O of Floats,  Prev: Float Arithmetic,  Up: Floating-point Functions

Comparison Functions
====================

 - Function: int mpf_cmp (mpf_t OP1, mpf_t OP2)
 - Function: int mpf_cmp_ui (mpf_t OP1, unsigned long int OP2)
 - Function: int mpf_cmp_si (mpf_t OP1, signed long int OP2)
     Compare OP1 and OP2.  Return a positive value if OP1 > OP2, zero
     if OP1 = OP2, and a negative value if OP1 < OP2.

 - Function: int mpf_eq (mpf_t OP1, mpf_t OP2, unsigned long int op3)
     Return non-zero if the first OP3 bits of OP1 and OP2 are equal,
     zero otherwise.  I.e., test of OP1 and OP2 are approximately equal.

 - Function: void mpf_reldiff (mpf_t ROP, mpf_t OP1, mpf_t OP2)
     Compute the relative difference between OP1 and OP2 and store the
     result in ROP.

 - Macro: int mpf_sgn (mpf_t OP)
     Return +1 if OP > 0, 0 if OP = 0, and -1 if OP < 0.

     This function is actually implemented as a macro.  It evaluates its
     arguments multiple times.


File: gmp.info,  Node: I/O of Floats,  Next: Miscellaneous Float Functions,  Prev: Float Comparison,  Up: Floating-point Functions

Input and Output Functions
==========================

   Functions that perform input from a stdio stream, and functions that
output to a stdio stream.  Passing a NULL pointer for a STREAM argument
to any of these functions will make them read from `stdin' and write to
`stdout', respectively.

   When using any of these functions, it is a good idea to include
`stdio.h' before `gmp.h', since that will allow `gmp.h' to define
prototypes for these functions.

 - Function: size_t mpf_out_str (FILE *STREAM, int BASE, size_t
          N_DIGITS, mpf_t OP)
     Output OP on stdio stream STREAM, as a string of digits in base
     BASE.  The base may vary from 2 to 36.  Print at most N_DIGITS
     significant digits, or if N_DIGITS is 0, the maximum number of
     digits accurately representable by OP.

     In addition to the significant digits, a leading `0.' and a
     trailing exponent, in the form `eNNN', are printed.  If BASE is
     greater than 10, `@' will be used instead of `e' as exponent
     delimiter.

     Return the number of bytes written, or if an error occurred,
     return 0.

 - Function: size_t mpf_inp_str (mpf_t ROP, FILE *STREAM, int BASE)
     Input a string in base BASE from stdio stream STREAM, and put the
     read float in ROP.  The string is of the form `M@N' or, if the
     base is 10 or less, alternatively `MeN'.  `M' is the mantissa and
     `N' is the exponent.  The mantissa is always in the specified
     base.  The exponent is either in the specified base or, if BASE is
     negative, in decimal.

     The argument BASE may be in the ranges 2 to 36, or -36 to -2.
     Negative values are used to specify that the exponent is in
     decimal.

     Unlike the corresponding `mpz' function, the base will not be
     determined from the leading characters of the string if BASE is 0.
     This is so that numbers like `0.23' are not interpreted as octal.

     Return the number of bytes read, or if an error occurred, return 0.


File: gmp.info,  Node: Miscellaneous Float Functions,  Prev: I/O of Floats,  Up: Floating-point Functions

Miscellaneous Functions
=======================

 - Function: void mpf_ceil (mpf_t ROP, mp_size_t OP)
 - Function: void mpf_floor (mpf_t ROP, mp_size_t OP)
 - Function: void mpf_trunc (mpf_t ROP, mp_size_t OP)
     Set ROP to OP rounded to an integer.  `mpf_ceil' rounds to the
     next higher integer, `mpf_floor' to the next lower, and
     `mpf_trunc' to the integer towards zero.

 - Function: void mpf_urandomb (mpf_t ROP, gmp_randstate_t STATE)
     Generate a universally distributed random float in the interval 0
     <= X < 1.

     The variable STATE must be initialized by calling one of the
     `gmp_randinit' functions (*Note Random State Initialization::)
     before invoking this function.

 - Function: void mpf_random2 (mpf_t ROP, mp_size_t MAX_SIZE, mp_exp_t
          MAX_EXP)
     Generate a random float of at most MAX_SIZE limbs, with long
     strings of zeros and ones in the binary representation.  The
     exponent of the number is in the interval -EXP to EXP.  This
     function is useful for testing functions and algorithms, since
     this kind of random numbers have proven to be more likely to
     trigger corner-case bugs.  Negative random numbers are generated
     when MAX_SIZE is negative.


File: gmp.info,  Node: Low-level Functions,  Next: Random Number Functions,  Prev: Floating-point Functions,  Up: Top

Low-level Functions
*******************

   This chapter describes low-level GMP functions, used to implement
the high-level GMP functions, but also intended for time-critical user
code.

   These functions start with the prefix `mpn_'.

   The `mpn' functions are designed to be as fast as possible, *not* to
provide a coherent calling interface.  The different functions have
somewhat similar interfaces, but there are variations that make them
hard to use.  These functions do as little as possible apart from the
real multiple precision computation, so that no time is spent on things
that not all callers need.

   A source operand is specified by a pointer to the least significant
limb and a limb count.  A destination operand is specified by just a
pointer.  It is the responsibility of the caller to ensure that the
destination has enough space for storing the result.

   With this way of specifying operands, it is possible to perform
computations on subranges of an argument, and store the result into a
subrange of a destination.

   A common requirement for all functions is that each source area
needs at least one limb.  No size argument may be zero.  Unless
otherwise stated, in-place operations are allowed where source and
destination are the same, but not where they only partly overlap.

   The `mpn' functions are the base for the implementation of the
`mpz_', `mpf_', and `mpq_' functions.

   This example adds the number beginning at S1P and the number
beginning at S2P and writes the sum at DESTP.  All areas have SIZE
limbs.

     cy = mpn_add_n (destp, s1p, s2p, size)

In the notation used here, a source operand is identified by the
pointer to the least significant limb, and the limb count in braces.
For example, {s1p, s1size}.

 - Function: mp_limb_t mpn_add_n (mp_limb_t *RP, const mp_limb_t *S1P,
          const mp_limb_t *S2P, mp_size_t SIZE)
     Add {S1P, SIZE} and {S2P, SIZE}, and write the SIZE least
     significant limbs of the result to RP.  Return carry, either 0 or
     1.

     This is the lowest-level function for addition.  It is the
     preferred function for addition, since it is written in assembly
     for most targets.  For addition of a variable to itself (i.e., S1P
     equals S2P, use `mpn_lshift' with a count of 1 for optimal speed.

 - Function: mp_limb_t mpn_add_1 (mp_limb_t *RP, const mp_limb_t *S1P,
          mp_size_t SIZE, mp_limb_t S2LIMB)
     Add {S1P, SIZE} and S2LIMB, and write the SIZE least significant
     limbs of the result to RP.  Return carry, either 0 or 1.

 - Function: mp_limb_t mpn_add (mp_limb_t *RP, const mp_limb_t *S1P,
          mp_size_t S1SIZE, const mp_limb_t *S2P, mp_size_t S2SIZE)
     Add {S1P, S1SIZE} and {S2P, S2SIZE}, and write the S1SIZE least
     significant limbs of the result to RP.  Return carry, either 0 or
     1.

     This function requires that S1SIZE is greater than or equal to
     S2SIZE.

 - Function: mp_limb_t mpn_sub_n (mp_limb_t *RP, const mp_limb_t *S1P,
          const mp_limb_t *S2P, mp_size_t SIZE)
     Subtract {S2P, S2SIZE} from {S1P, SIZE}, and write the SIZE least
     significant limbs of the result to RP.  Return borrow, either 0 or
     1.

     This is the lowest-level function for subtraction.  It is the
     preferred function for subtraction, since it is written in
     assembly for most targets.

 - Function: mp_limb_t mpn_sub_1 (mp_limb_t *RP, const mp_limb_t *S1P,
          mp_size_t SIZE, mp_limb_t S2LIMB)
     Subtract S2LIMB from {S1P, SIZE}, and write the SIZE least
     significant limbs of the result to RP.  Return borrow, either 0 or
     1.

 - Function: mp_limb_t mpn_sub (mp_limb_t *RP, const mp_limb_t *S1P,
          mp_size_t S1SIZE, const mp_limb_t *S2P, mp_size_t S2SIZE)
     Subtract {S2P, S2SIZE} from {S1P, S1SIZE}, and write the S1SIZE
     least significant limbs of the result to RP.  Return borrow,
     either 0 or 1.

     This function requires that S1SIZE is greater than or equal to
     S2SIZE.

 - Function: void mpn_mul_n (mp_limb_t *RP, const mp_limb_t *S1P, const
          mp_limb_t *S2P, mp_size_t SIZE)
     Multiply {S1P, SIZE} and {S2P, SIZE}, and write the *entire*
     result to RP.

     The destination has to have space for 2SIZE limbs, even if the
     significant result might be one limb smaller.

 - Function: mp_limb_t mpn_mul_1 (mp_limb_t *RP, const mp_limb_t *S1P,
          mp_size_t SIZE, mp_limb_t S2LIMB)
     Multiply {S1P, SIZE} and S2LIMB, and write the SIZE least
     significant limbs of the product to RP.  Return the most
     significant limb of the product.

     This is a low-level function that is a building block for general
     multiplication as well as other operations in GMP.  It is written
     in assembly for most targets.

     Don't call this function if S2LIMB is a power of 2; use
     `mpn_lshift' with a count equal to the logarithm of S2LIMB
     instead, for optimal speed.

 - Function: mp_limb_t mpn_addmul_1 (mp_limb_t *RP, const mp_limb_t
          *S1P, mp_size_t SIZE, mp_limb_t S2LIMB)
     Multiply {S1P, SIZE} and S2LIMB, and add the SIZE least
     significant limbs of the product to {RP, SIZE} and write the
     result to RP.  Return the most significant limb of the product,
     plus carry-out from the addition.

     This is a low-level function that is a building block for general
     multiplication as well as other operations in GMP.  It is written
     in assembly for most targets.

 - Function: mp_limb_t mpn_submul_1 (mp_limb_t *RP, const mp_limb_t
          *S1P, mp_size_t SIZE, mp_limb_t S2LIMB)
     Multiply {S1P, SIZE} and S2LIMB, and subtract the SIZE least
     significant limbs of the product from {RP, SIZE} and write the
     result to RP.  Return the most significant limb of the product,
     minus borrow-out from the subtraction.

     This is a low-level function that is a building block for general
     multiplication and division as well as other operations in GMP.
     It is written in assembly for most targets.

 - Function: mp_limb_t mpn_mul (mp_limb_t *RP, const mp_limb_t *S1P,
          mp_size_t S1SIZE, const mp_limb_t *S2P, mp_size_t S2SIZE)
     Multiply {S1P, S1SIZE} and {S2P, S2SIZE}, and write the result to
     RP.  Return the most significant limb of the result.

     The destination has to have space for S1SIZE + S2SIZE limbs, even
     if the result might be one limb smaller.

     This function requires that S1SIZE is greater than or equal to
     S2SIZE.  The destination must be distinct from either input
     operands.

 - Function: mp_limb_t mpn_divrem (mp_limb_t *R1P, mp_size_t XSIZE,
          mp_limb_t *RS2P, mp_size_t RS2SIZE, const mp_limb_t *S3P,
          mp_size_t S3SIZE)
     Divide {RS2P, RS2SIZE} by {S3P, S3SIZE}, and write the quotient at
     R1P, with the exception of the most significant limb, which is
     returned.  The remainder replaces the dividend at RS2P; it will be
     S3SIZE limbs long (i.e., as many limbs as the divisor).

     In addition to an integer quotient, XSIZE fraction limbs are
     developed, and stored after the integral limbs.  For most usages,
     XSIZE will be zero.

     It is required that RS2SIZE is greater than or equal to S3SIZE.
     It is required that the most significant bit of the divisor is set.

     If the quotient is not needed, pass RS2P + S3SIZE as R1P.  Aside
     from that special case, no overlap between arguments is permitted.

     Return the most significant limb of the quotient, either 0 or 1.

     The area at R1P needs to be RS2SIZE - S3SIZE + XSIZE limbs large.

 - Function: mp_limb_t mpn_divrem_1 (mp_limb_t *R1P, mp_size_t XSIZE,
          mp_limb_t *S2P, mp_size_t S2SIZE, mp_limb_t S3LIMB)
     Divide {S2P, S2SIZE} by S3LIMB, and write the quotient at R1P.
     Return the remainder.

     The integer quotient is written to {R1P+XSIZE, S2SIZE} and in
     addition XSIZE fraction limbs are developed and written to {R1P,
     XSIZE}.  Either or both S2SIZE and XSIZE can be zero.  For most
     usages, XSIZE will be zero.

     The areas at R1P and S2P have to be identical or completely
     separate, not partially overlapping.

 - Function: mp_limb_t mpn_divmod (mp_limb_t *R1P, mp_limb_t *RS2P,
          mp_size_t RS2SIZE, const mp_limb_t *S3P, mp_size_t S3SIZE)
     *This interface is obsolete.  It will disappear from future
     releases.  Use `mpn_divrem' in its stead.*

 - Function: mp_limb_t mpn_divmod_1 (mp_limb_t *R1P, mp_limb_t *S2P,
          mp_size_t S2SIZE, mp_limb_t S3LIMB)
     *This interface is obsolete.  It will disappear from future
     releases.  Use `mpn_divrem_1' in its stead.*

 - Function: mp_limb_t mpn_divexact_by3 (mp_limb_t *RP, mp_limb_t *SP,
          mp_size_t SIZE)
     Divide {SP, SIZE} by 3, expecting it to divide exactly, and
     writing the quotient to {RP, SIZE}.  If 3 divides exactly, the
     return value is zero and the quotient is correct.  If not, the
     return value is non-zero and the quotient won't be anything useful.

     This routine uses a multiply-by-inverse and will be faster than
     `mpn_divrem_1' on CPUs with fast multiplication but slow division.

 - Function: mp_limb_t mpn_mod_1 (mp_limb_t *S1P, mp_size_t S1SIZE,
          mp_limb_t S2LIMB)
     Divide {S1P, S1SIZE} by S2LIMB, and return the remainder.  S1SIZE
     can be zero.

 - Function: mp_limb_t mpn_preinv_mod_1 (mp_limb_t *S1P, mp_size_t
          S1SIZE, mp_limb_t S2LIMB, mp_limb_t S3LIMB)
     *This interface is obsolete.  It will disappear from future
     releases.  Use `mpn_mod_1' in its stead.*

 - Function: mp_limb_t mpn_bdivmod (mp_limb_t *RP, mp_limb_t *S1P,
          mp_size_t S1SIZE, const mp_limb_t *S2P, mp_size_t S2SIZE,
          unsigned long int D)
     The function puts the low [D/BITS_PER_MP_LIMB] limbs of Q = {S1P,
     S1SIZE}/{S2P, S2SIZE} mod 2^D at RP, and returns the high D mod
     BITS_PER_MP_LIMB bits of Q.

     {S1P, S1SIZE} - Q * {S2P, S2SIZE} mod 2^(S1SIZE*BITS_PER_MP_LIMB)
     is placed at S1P.  Since the low [D/BITS_PER_MP_LIMB] limbs of
     this difference are zero, it is possible to overwrite the low
     limbs at S1P with this difference, provided RP <= S1P.

     This function requires that S1SIZE * BITS_PER_MP_LIMB >= D, and
     that {S2P, S2SIZE} is odd.

     *This interface is preliminary.  It might change incompatibly in
     future revisions.*

 - Function: mp_limb_t mpn_lshift (mp_limb_t *RP, const mp_limb_t
          *SRC_PTR, mp_size_t SRC_SIZE, unsigned long int COUNT)
     Shift {SRC_PTR, SRC_SIZE} COUNT bits to the left, and write the
     SRC_SIZE least significant limbs of the result to RP.  COUNT might
     be in the range 1 to n - 1, on an n-bit machine. The bits shifted
     out to the left are returned.

     Overlapping of the destination space and the source space is
     allowed in this function, provided RP >= SRC_PTR.

     This function is written in assembly for most targets.

 - Function: mp_limp_t mpn_rshift (mp_limb_t *RP, const mp_limb_t
          *SRC_PTR, mp_size_t SRC_SIZE, unsigned long int COUNT)
     Shift {SRC_PTR, SRC_SIZE} COUNT bits to the right, and write the
     SRC_SIZE most significant limbs of the result to RP.  COUNT might
     be in the range 1 to n - 1, on an n-bit machine.  The bits shifted
     out to the right are returned.

     Overlapping of the destination space and the source space is
     allowed in this function, provided RP <= SRC_PTR.

     This function is written in assembly for most targets.

 - Function: int mpn_cmp (const mp_limb_t *S1P, const mp_limb_t *S2P,
          mp_size_t SIZE)
     Compare {S1P, SIZE} and {S2P, SIZE} and return a positive value if
     s1 > src2, 0 of they are equal, and a negative value if s1 < src2.

 - Function: mp_size_t mpn_gcd (mp_limb_t *RP, mp_limb_t *S1P,
          mp_size_t S1SIZE, mp_limb_t *S2P, mp_size_t S2SIZE)
     Puts at RP the greatest common divisor of {S1P, S1SIZE} and {S2P,
     S2SIZE}; both source operands are destroyed by the operation.  The
     size in limbs of the greatest common divisor is returned.

     {S1P, S1SIZE} must have at least as many bits as {S2P, S2SIZE},
     and {S2P, S2SIZE} must be odd.

 - Function: mp_limb_t mpn_gcd_1 (const mp_limb_t *S1P, mp_size_t
          S1SIZE, mp_limb_t S2LIMB)
     Return the greatest common divisor of {S1P, S1SIZE} and S2LIMB,
     where S2LIMB (as well as S1SIZE) must be different from 0.

 - Function: mp_size_t mpn_gcdext (mp_limb_t *R1P, mp_limb_t *R2P,
          mp_size_t *R2SIZE, mp_limb_t *S1P, mp_size_t S1SIZE,
          mp_limb_t *S2P, mp_size_t S2SIZE)
     Compute the greatest common divisor of {S1P, S1SIZE} and {S2P,
     S2SIZE}, and store it at R1P.  Write the first cofactor at R2P.
     Both source operands are clobbered.

     {S1P, S1SIZE} must be greater or equal to {S2P, S2SIZE}.  Neither
     operand may equal 0.

     The size and sign of the first cofactor are written at *R2SIZE; the
     actual size of the cofactor is the absolute value of *R2SIZE; the
     sign of the cofactor is negative iff *R2SIZE is negative.

     The size in limbs of the greatest common divisor is returned.

 - Function: mp_size_t mpn_sqrtrem (mp_limb_t *R1P, mp_limb_t *R2P,
          const mp_limb_t *SP, mp_size_t SIZE)
     Compute the square root of {SP, SIZE} and put the result at R1P.
     Write the remainder at R2P, unless R2P is NULL.

     Return the size of the remainder, whether R2P was NULL or non-NULL.
     Iff the operand was a perfect square, the return value will be 0.

     The areas at R1P and SP have to be distinct.  The areas at R2P and
     SP have to be identical or completely separate, not partially
     overlapping.

     The area at R1P needs to have space for ceil(SIZE/2) limbs.  The
     area at R2P needs to be SIZE limbs large.

 - Function: mp_size_t mpn_get_str (unsigned char *STR, int BASE,
          mp_limb_t *S1P, mp_size_t S1SIZE)
     Convert {S1P, S1SIZE} to a raw unsigned char array in base BASE.
     The string is not in ASCII; to convert it to printable format, add
     the ASCII codes for `0' or `A', depending on the base and range.
     There may be leading zeros in the string.

     The area at S1P is clobbered.

     Return the number of characters in STR.

     The area at STR has to have space for the largest possible number
     represented by a S1SIZE long limb array, plus one extra character.

 - Function: mp_size_t mpn_set_str (mp_limb_t *R1P, const char *STR,
          size_t STRSIZE, int BASE)
     Convert the raw unsigned char array at STR of length STRSIZE to a
     limb array {S1P, S1SIZE}.  The base of STR is BASE.

     Return the number of limbs stored in R1P.

 - Function: unsigned long int mpn_scan0 (const mp_limb_t *S1P,
          unsigned long int BIT)
     Scan S1P from bit position BIT for the next clear bit.

     It is required that there be a clear bit within the area at S1P at
     or beyond bit position BIT, so that the function has something to
     return.

 - Function: unsigned long int mpn_scan1 (const mp_limb_t *S1P,
          unsigned long int BIT)
     Scan S1P from bit position BIT for the next set bit.

     It is required that there be a set bit within the area at S1P at or
     beyond bit position BIT, so that the function has something to
     return.

 - Function: void mpn_random (mp_limb_t *R1P, mp_size_t R1SIZE)
 - Function: void mpn_random2 (mp_limb_t *R1P, mp_size_t R1SIZE)
     Generate a random number of length R1SIZE and store it at R1P.
     The most significant limb is always non-zero.  `mpn_random'
     generates uniformly distributed limb data, `mpn_random2' generates
     long strings of zeros and ones in the binary representation.

     `mpn_random2' is intended for testing the correctness of the `mpn'
     routines.

 - Function: unsigned long int mpn_popcount (const mp_limb_t *S1P,
          unsigned long int SIZE)
     Count the number of set bits in {S1P, SIZE}.

 - Function: unsigned long int mpn_hamdist (const mp_limb_t *S1P, const
          mp_limb_t *S2P, unsigned long int SIZE)
     Compute the hamming distance between {S1P, SIZE} and {S2P, SIZE}.

 - Function: int mpn_perfect_square_p (const mp_limb_t *S1P, mp_size_t
          SIZE)
     Return non-zero iff {S1P, SIZE} is a perfect square.


File: gmp.info,  Node: Random Number Functions,  Next: BSD Compatible Functions,  Prev: Low-level Functions,  Up: Top

Random Number Functions
***********************

   There are two groups of random number functions in GNU MP; older
functions that call C library random number generators, rely on a global
state, and aren't very random; and newer functions that don't have these
problems.  The newer functions are self-contained, they accept a random
state parameter that supplants global state, and generate good random
numbers.

   The random state parameter is of the type `gmp_randstate_t'.  It
must be initialized by a call to one of the `gmp_randinit' functions
(*Note Random State Initialization::).  The initial seed is set using
one of the `gmp_randseed' functions (*Note Random State
Initialization::).

   The size of the seed determines the number of different sequences of
random numbers that is possible to generate.  The "quality" of the seed
is the randomness of a given seed compared to the previous seed used
and affects the randomness of separate number sequences.

   The algorithm for assigning seed is critical if the generated random
numbers are to be used for important applications, such as generating
cryptographic keys.

   The traditional method is to use the current system time for
seeding.  One has to be careful when using the current time though.  If
the application seeds the random functions very often, say several
times per second, and the resolution of the system clock is
comparatively low, like one second, the same sequence of numbers will
be generated until the system clock ticks.  Furthermore, the current
system time is quite easy to guess, so a system depending on any
unpredictability of the random number sequence should absolutely not
use that as its only source for a seed value.

   On some systems there is a special device, often called
`/dev/random', which provides a source of somewhat random numbers more
usable as seed.

   The functions actually generating random functions are documented
under "Miscellaneous Functions" in their respective function class:
*Note Miscellaneous Integer Functions::, *Note Miscellaneous Float
Functions::.

* Menu:

* Random State Initialization::	How to initialize a random state.

